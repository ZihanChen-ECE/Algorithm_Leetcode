1. 划分型

给定长度为N的序列或字符串，要求不限划分或划分为k段，问是否可以划分或者最大/小划分

注意划分型都是连续划分。如果不连续就是背包
```
例1. 给定n, 求n可以被划分为多少完全平方数只和
f[i] = min{f[i - j^2] + 1}, 1<=j*j<=i
f[0] = 0

例2. 给一个字符串，将这个串进行划分，使得每个划分都是palindrome, 求最少划分几次
f[i] = min{f[j] if s[j...i-1] is palindrome} + 1, 0<=j<=i-1
f[0] = 0

例3. 给一个array，一个k，要求对array划分为不超过k段，使得所有段的数字之和的最大值最小。return这个最小值。
e.g., A = [3, 2, 4], k = 2, 则return 5

首先，肯定是越划分值越小，因此必须划分k次
dp[k][i] = min{max{dp[k-1][j], A[j] + ... + A[i - 1]}}, 0 <= j <= i
dp[0][0] = 0
dp[k][0] = 0
dp[0][i] = INT_MAX;
同时 A[j] + ... + A[i-1]可以用prefix sum来做。

同时如果k > N, 可以让k = N。
```

2. 博弈型

两方游戏，在一定规则下依次出招。如果一方条件满足，则胜
```
例1. coins in a line
有N个石子，两个人取，每人取1或2个，取完的胜。问先取的是不是必胜
针对当前的n，都可以知道是否为必胜或者必败。
所以走了一步以后，如果之后必胜则当前必败，否则必胜
f[i] = f[i-1] == false || f[i-2] == false;
f[1] = f[2] = true;

例2. coins in a line III
有N个石子，两个人取，每个人只能取第一个或者最后一个，并记下值，取得最大值的胜。问先取的是不是必胜
因为有这里本质是diff，因此可以针对diff进行dp
f[i][j] = max{a[i] - f[i+1][j], a[j] - f[i][j-1]}
表示一方在面对a[i...j]这些数字时，能得到的最大的与对手的数字差（either取头或取尾）


```

3. 区间型

消去型题目不能顺着题目去想，不然就需要keep一个fresh sequence。反之，思考最后的情况来想。给一个fake boundary。独立地去想