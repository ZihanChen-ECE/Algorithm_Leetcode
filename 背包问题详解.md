背包问题分类

背包有最大称重，每种物品都有数量，重量，价格

背包由于需要确保当前的m < M, 故dp必须2D
```cpp
例1. 基本背包
N个物品，重量为A[N], 一个背包最大重量为M，求最多能fill多少重量？
错误示范：dp[i] = max{dp[i-A[j]]} + 1, 0<=j<i
因为前面的物品拼出的不一定式不超过target的最大重量
正确做法：
dp[i][w] = dp[i-1][w] or dp[i-1][w-A[i-1]]
表示能否用前i个物品拼出重量w
dp[0][0] = true;
dp[0][m] = false; // 1 <= m <= M
最后看dp[N][m] == true的m的最大值


例2. 给定A[N]和target，问多少组合使得和为target
dp[i][w] = dp[i-1][w] + dp[i-1][w-A[i-1]]
前i个物品有多少拼出m的组合
f[0][0] = 1;
f[0][1...M] = 0;
f[N][target]即可

例3. 给定A[N]和target，问多少组合使得和为target。并且每个数字都能用很多次，并且顺序是考虑的（如1 2 1 与 1 1 2是两个组合）
与coin change很像
f[i] = 多少组合能拼出重量i
f[i] = sum(f[i-A[j]]), 0 <= i < j
f[0] = 1;

例4. 给定A[N]和V[N], 背包承重M，求最多能带走多大价值的物品
dp[i][m] = max{dp[i-1][m], dp[i-1][m - A[i-1]] + V[i-1] if (m >= A[i-1] && dp[i-1][m - A[i-1]] != -1)}
这里之所以是m - A[i-1] 以及V[i-1]是因为i代表第i个物品是从1开始的，0是一个虚拟物品
dp[0][0] = 0;
dp[0][1...M] = -1;
return max{dp[N][m] if dp[N][m] != -1}, 0<= m <=M 

例5. 给定A[N]和V[N], 背包承重M，每个物品都可以取无限次，求最多能带走多大价值的物品
dp[i][m] = max{dp[i-1][m], dp[i][m-A[i-1]] + V[i-1] if m > A[i] else -1}, 0<=i<N
dp[0][0] = 1;
返回max{f[m]};



```


所有背包问题都能backtrack，但是这里讨论的是dp的解法

